recursion으로 만들 수 있는 정렬방법이 merge sort 병합정렬이라고 한다.
이것은 확실히 bubble sort랑 selection sort보다 뛰어난 알고리즘으로 알려져있다. represented
Big-O의 표기법으로 봐도 더이상 n^2이 아니다.
의사코드로 표현해 보면
입력으로 어떤 정보의 배열이 주어졌을 때 
If only one item
  Return
Else
  Sort left half of items
  Sort right half of items
  Merge sorted halves
  
항목이 한 개라면 이미 정렬된 거나 다름없다.
다른 경우는
모든 배열을 정렬하고 싶다면
우선 왼쪽 절반을 정렬하고
오른쪽 절반을 정렬한 뒤
짜깁기를 하듯이 하나의 배열로 합치면 됩니다
합쳐진 배열 또한 정렬되도록 말입니다
병합 정렬은 세 단계로 구성됩니다
왼쪽 정렬과 오른쪽 정렬
그리고 이 두 배열의 병합입니다

병합이란 두 배열 중에서 가장 작은 값을 꺼내
다른 배열의 가장 작은 값 다음에 두는 과정을 말합니다

실제로 한 것은 크기 8의 배열을 쪼개어
어느 순간 크기 1의 배열 8개를 만든 겁니다
항목이 한 개면 더 이상 할 게 없으니
반환합니다
그다음에는 크기가 2인 배열 4개로 만들고
그리고 크기가 4인 배열 2개를 만들고
결과적으로
크기가 8인 하나의 배열로 합칠 수 있었습니다

 매번 무언가를 계속해서 절반으로 나눌 때
이 과정을 설명하는 수식이나 함수는 로그로 표현할 수 있다.

크기 8인 배열을 쪼개서 크기 1인 배열 8개로 만드는 데
필요한 과정은 밑이 2인 log n 입니다
대략 log n이라 하죠
이 그림의 높이가 log n입니다
쪼개는 과정이 한 번 있을 때마다 합치는 과정이 있었습니다
총 8개의 항목을 합쳤습니다
즉 모든 n개의 항목을 확인합니다

높이는 log n이 됩니다
나눌 수 있는 횟수가 log n 번이기 때문입니다


그래서 결국 이 병합정렬을 실행시간은
nlog(n)이 되는 것이다.

O(nlogn)
그리고 
Omega(nlogn)
실행시간의 하한도 nlogn이다.
이건 bubble sort처럼 swap을 더이상 안 한다고 return을 할 수 없기 때문이다.

그리고 실행시간의 상한과 하한이 같을 때 Theta라고 한다.
그래서 
Θ(n^2) - selection sort
Θ(nlogn) - merge sort
Θ(n)
Θ(logn)
Θ(1)

아무튼 nlogn을 시각화 자료로 봤는데 엄청 빨라졌다.
그래서 코드의 최종 목적은 정확한 코딩이 아니라
효율적인 코딩으로 잡아야한다.
